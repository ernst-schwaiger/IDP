\section{Software architecture and design}
\label{chapter2}

\paragraph
{}
	%If the acc is turned on, a 5ms task on Node 2 periodically requests distance readings from Node 1. Out of the readings it derives the new speed of the car. In alarm situations, e.g. failed readings, an object gets too close, no bt communication available, ... the acc turns off and alarms the driver to take over.
When the ACC is activated, Node 2 executes a periodic task every 5 ms to request distance measurements from Node 1. Based on these readings, it calculates the updated speed of the virtual car. In case of an alarm situation - such as invalid or missing sensor data, an object detected at critical distance, or a loss of Bluetooth communication - the ACC is automatically deactivated and the driver is alerted to take control.

\subsection{Software modules}

\begin{itemize}
	\item bt\_connection on Node 1 and Node 2
	\item acc\_control on Node 2
	\item proximity\_reader on Node 1
	\item display\_control on Node 2
	\item fault\_injection\_agent
\end{itemize}


\subsubsection{Safety related modules}
	% \begin{enumerate}
	% 	\item Modul x: \\
	% 		Description:\\
	% 		Functions:\\
	% 		Data:\\
	% 		Requirements see: \ref{req.1.1}, .... \\
	% \end{enumerate}


\subsubsection{Security related modules}

\subsubsection{Modules with no influence on Safety and Security}

\subsection{Libraries}

Description of used function with parameters.


\subsection{Interrupts}

Definition of priorities.

\subsection{Pinout}

\subsection{GUI}

\ref{fig:gui} shows the dashboard GUI, containing the controls for accelerating and decelerating the vehicle, and for activating adaptive cruise control. It also contains elements showing the vehicles current speed, the distance to the nearest object in front of the car, and the status of the ACC system.

\begin{figure}[h]
	\includegraphics[height=50mm]{images/GUI.png}
	\centering
	\caption{Dashboard GUI}
	\label{fig:gui}
\end{figure}

\begin{enumerate}
  \item ACC Status LED: Shows the status of the ACC system, green if it is in an operational state, red, if ACC  is in a failed state.
  \item ACC Button: Push Button to activate ACC. Can only be pushed if ACC is in operational state and not turned on already.
  \item Accelerate Button: Increases the vehicle speed by 5 km/h (up to 200 km/h), deactivates ACC, if it was active.
  \item Decelerate Button: Decreases the vehicle speed by 5 km/h (down to 0 km/h), deactivates ACC, if it was active.
  \item Speed Display: Shows current vehicle speed
  \item Distance Display: Shows distance of the nearest object in front of the vehicle, does not display anything if ACC is in failed state.
\end{enumerate}

\subsection{Communication}

\paragraph{} Immediately after the communication is set up, Node 1 and Node 2 exchange 32 byte random numbers. These two numbers and a 32 byte pre-shared key are concatenated and put into a key derivation function returning a 256 bit AES session key used for HMAC generation. The message layout for these messages is shown in the first message in \ref{fig:msg}.

\paragraph{}The messages which Node 1 and Node 2 are exchanging contain two fields:
\begin{itemize}
	\item MessageType: 1 byte, set to zero
	\item Random: 32 bytes, a random number generated by the sender node
\end{itemize}

FIXME: After key establishment, we should use a challenge-response round, so each participant proves to the other it owns the PSK. If that does not work on both sides, the connection should be dropped.

\paragraph{} After the common session key is established, the application uses a client server communication pattern, Node 1 acting as server and Node 2 acting as client. Node 2 periodically sends request messages to Node 1 which sends response messages. The message layout looks like depicted in the second and third messages in \ref{fig:msg}. All multi byte fields are encoded as big-endian/in network byte order, i.e. the first byte of a field contains the MSB.

\paragraph{} All messages have the following layout:
\begin{itemize}
	\item MessageType: 1 byte, indicates the content of the Payload field
	\item Counter: 4 bytes, zero based 32 bit unsigned integer
	\item Payload: Holds the transmitted information
	\item HMAC: SHA-256 based HMAC, protecting all fields before the HMAC
\end{itemize}

\paragraph{} The request message, sent from Node 2 to Node 1, holds the \emph{Cmd} field, conveying the particular request to Node 2. Currently, only \emph{0x01} is supported, which requests the current distance reading from Node2.

\paragraph{} The response message, sent from Node 1 to Node 2, holds the \emph{Distance} field, conveying the most recent distance readings from Node1. In the error free case, that field holds values in the range of [0..400] indicating the measured distance to the next object in [m]. A value of \emph{0} indicates a measured distance below one meter, while a value of \emph{400} indicates a distance of 400 meters or a greater distance. A value of \emph{0xffff} indicates that both sensors yielded inconsistent readings (FIXME: Define what inconsistent means in our system), and the value of \emph{0xfffe} indicates that Node 1 detected a failure of one or both procimity sensors.


\begin{figure}[h]
	\includegraphics[height=50mm]{images/MessageLayout.png}
	\centering
	\caption{Layout of Messages}
	\label{fig:msg}
\end{figure}
